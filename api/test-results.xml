<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="6" skipped="0" tests="9" time="8.969" timestamp="2025-11-12T18:39:39.005280" hostname="Mac.lan"><testcase classname="tests.simple_performance_test" name="test_imports" time="0.001" /><testcase classname="tests.simple_performance_test" name="test_file_structure" time="0.001" /><testcase classname="tests.simple_performance_test" name="test_api_integration" time="0.000" /><testcase classname="tests.test_metrics" name="test_quality_metrics" time="0.135"><failure message="sqlalchemy.exc.OperationalError: (psycopg.OperationalError) connection failed: connection to server at &quot;127.0.0.1&quot;, port 5432 failed: FATAL:  password authentication failed for user &quot;postgres&quot;&#10;Multiple connection attempts failed. All failures were:&#10;- host: 'localhost', port: 5432, hostaddr: '::1': connection failed: connection to server at &quot;::1&quot;, port 5432 failed: FATAL:  password authentication failed for user &quot;postgres&quot;&#10;- host: 'localhost', port: 5432, hostaddr: '127.0.0.1': connection failed: connection to server at &quot;127.0.0.1&quot;, port 5432 failed: FATAL:  password authentication failed for user &quot;postgres&quot;&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)">self = &lt;sqlalchemy.engine.base.Connection object at 0x17d9de8a0&gt;
engine = Engine(postgresql+psycopg://postgres:***@localhost:5432/data_hygiene), connection = None, _has_events = None
_allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
&gt;               self._dbapi_connection = engine.raw_connection()

/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3301: in raw_connection
    return self.pool.connect()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/default.py:629: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = &lt;class 'psycopg.Connection'&gt;
conninfo = "host=localhost dbname=data_hygiene user=postgres password=postgres port=5432 options='-c statement_timeout=30000' hostaddr=127.0.0.1"
autocommit = False, prepare_threshold = 5, context = &lt;psycopg.adapt.AdaptersMap object at 0x107c0ffe0&gt;, row_factory = None
cursor_factory = None
kwargs = {'dbname': 'data_hygiene', 'host': 'localhost', 'options': '-c statement_timeout=30000', 'password': 'postgres', ...}
params = {'dbname': 'data_hygiene', 'host': 'localhost', 'options': '-c statement_timeout=30000', 'password': 'postgres', ...}, timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -&gt; Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        conn_errors: list[tuple[e.Error, str]] = []
        for attempt in attempts:
            tdescr = (attempt.get("host"), attempt.get("port"), attempt.get("hostaddr"))
            descr = "host: %r, port: %r, hostaddr: %r" % tdescr
            logger.debug("connection attempt: %s", descr)
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e.Error as ex:
                logger.debug("connection failed: %s: %s", descr, str(ex))
                conn_errors.append((ex, descr))
            except e._NO_TRACEBACK as ex:
                raise ex.with_traceback(None)
            else:
                logger.debug("connection succeeded: %s", descr)
                break
    
        if not rv:
            last_ex = conn_errors[-1][0]
            if len(conn_errors) == 1:
                raise last_ex.with_traceback(None)
    
            # Create a new exception with the same type as the last one, containing
            # all attempt errors while preserving backward compatibility.
            lines = [str(last_ex)]
            lines.append("Multiple connection attempts failed. All failures were:")
            lines.extend((f"- {descr}: {error}" for error, descr in conn_errors))
&gt;           raise type(last_ex)("\n".join(lines)).with_traceback(None)
E           psycopg.OperationalError: connection failed: connection to server at "127.0.0.1", port 5432 failed: FATAL:  password authentication failed for user "postgres"
E           Multiple connection attempts failed. All failures were:
E           - host: 'localhost', port: 5432, hostaddr: '::1': connection failed: connection to server at "::1", port 5432 failed: FATAL:  password authentication failed for user "postgres"
E           - host: 'localhost', port: 5432, hostaddr: '127.0.0.1': connection failed: connection to server at "127.0.0.1", port 5432 failed: FATAL:  password authentication failed for user "postgres"

/opt/anaconda3/lib/python3.12/site-packages/psycopg/connection.py:127: OperationalError

The above exception was the direct cause of the following exception:

    def test_quality_metrics():
        # Get a database session
        db = next(get_session())
    
        try:
            # Get the first execution
&gt;           execution = db.query(Execution).first()

tests/test_metrics.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2759: in first
    return self.limit(1)._iter().first()  # type: ignore
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2857: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2351: in execute
    return self._execute_internal(
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2239: in _execute_internal
    conn = self._connection_for_bind(bind)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2108: in _connection_for_bind
    return trans._connection_for_bind(engine, execution_options)
&lt;string&gt;:2: in _connection_for_bind
    ???
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1187: in _connection_for_bind
    conn = bind.connect()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3277: in connect
    return self._connection_cls(self)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2440: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3301: in raw_connection
    return self.pool.connect()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/default.py:629: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = &lt;class 'psycopg.Connection'&gt;
conninfo = "host=localhost dbname=data_hygiene user=postgres password=postgres port=5432 options='-c statement_timeout=30000' hostaddr=127.0.0.1"
autocommit = False, prepare_threshold = 5, context = &lt;psycopg.adapt.AdaptersMap object at 0x107c0ffe0&gt;, row_factory = None
cursor_factory = None
kwargs = {'dbname': 'data_hygiene', 'host': 'localhost', 'options': '-c statement_timeout=30000', 'password': 'postgres', ...}
params = {'dbname': 'data_hygiene', 'host': 'localhost', 'options': '-c statement_timeout=30000', 'password': 'postgres', ...}, timeout = 130

    @classmethod
    def connect(
        cls,
        conninfo: str = "",
        *,
        autocommit: bool = False,
        prepare_threshold: int | None = 5,
        context: AdaptContext | None = None,
        row_factory: RowFactory[Row] | None = None,
        cursor_factory: type[Cursor[Row]] | None = None,
        **kwargs: ConnParam,
    ) -&gt; Self:
        """
        Connect to a database server and return a new `Connection` instance.
        """
    
        params = cls._get_connection_params(conninfo, **kwargs)
        timeout = timeout_from_conninfo(params)
        rv = None
        attempts = conninfo_attempts(params)
        conn_errors: list[tuple[e.Error, str]] = []
        for attempt in attempts:
            tdescr = (attempt.get("host"), attempt.get("port"), attempt.get("hostaddr"))
            descr = "host: %r, port: %r, hostaddr: %r" % tdescr
            logger.debug("connection attempt: %s", descr)
            try:
                conninfo = make_conninfo("", **attempt)
                gen = cls._connect_gen(conninfo, timeout=timeout)
                rv = waiting.wait_conn(gen, interval=_WAIT_INTERVAL)
            except e.Error as ex:
                logger.debug("connection failed: %s: %s", descr, str(ex))
                conn_errors.append((ex, descr))
            except e._NO_TRACEBACK as ex:
                raise ex.with_traceback(None)
            else:
                logger.debug("connection succeeded: %s", descr)
                break
    
        if not rv:
            last_ex = conn_errors[-1][0]
            if len(conn_errors) == 1:
                raise last_ex.with_traceback(None)
    
            # Create a new exception with the same type as the last one, containing
            # all attempt errors while preserving backward compatibility.
            lines = [str(last_ex)]
            lines.append("Multiple connection attempts failed. All failures were:")
            lines.extend((f"- {descr}: {error}" for error, descr in conn_errors))
&gt;           raise type(last_ex)("\n".join(lines)).with_traceback(None)
E           sqlalchemy.exc.OperationalError: (psycopg.OperationalError) connection failed: connection to server at "127.0.0.1", port 5432 failed: FATAL:  password authentication failed for user "postgres"
E           Multiple connection attempts failed. All failures were:
E           - host: 'localhost', port: 5432, hostaddr: '::1': connection failed: connection to server at "::1", port 5432 failed: FATAL:  password authentication failed for user "postgres"
E           - host: 'localhost', port: 5432, hostaddr: '127.0.0.1': connection failed: connection to server at "127.0.0.1", port 5432 failed: FATAL:  password authentication failed for user "postgres"
E           (Background on this error at: https://sqlalche.me/e/20/e3q8)

/opt/anaconda3/lib/python3.12/site-packages/psycopg/connection.py:127: OperationalError</failure></testcase><testcase classname="tests.test_upload" name="test_upload_valid_file" time="0.004"><failure message="Failed: Fixture &quot;mock_user&quot; called directly. Fixtures are not meant to be called directly,&#10;but are created automatically when test functions request them as parameters.&#10;See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and&#10;https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.">Fixture "mock_user" called directly. Fixtures are not meant to be called directly,
but are created automatically when test functions request them as parameters.
See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and
https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.</failure></testcase><testcase classname="tests.test_upload" name="test_upload_invalid_extension" time="0.001"><failure message="Failed: Fixture &quot;mock_user&quot; called directly. Fixtures are not meant to be called directly,&#10;but are created automatically when test functions request them as parameters.&#10;See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and&#10;https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.">Fixture "mock_user" called directly. Fixtures are not meant to be called directly,
but are created automatically when test functions request them as parameters.
See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and
https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.</failure></testcase><testcase classname="tests.test_upload" name="test_upload_double_extension" time="0.001"><failure message="Failed: Fixture &quot;mock_user&quot; called directly. Fixtures are not meant to be called directly,&#10;but are created automatically when test functions request them as parameters.&#10;See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and&#10;https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.">Fixture "mock_user" called directly. Fixtures are not meant to be called directly,
but are created automatically when test functions request them as parameters.
See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and
https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.</failure></testcase><testcase classname="tests.test_upload" name="test_upload_mismatched_mime_type" time="0.001"><failure message="Failed: Fixture &quot;mock_user&quot; called directly. Fixtures are not meant to be called directly,&#10;but are created automatically when test functions request them as parameters.&#10;See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and&#10;https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.">Fixture "mock_user" called directly. Fixtures are not meant to be called directly,
but are created automatically when test functions request them as parameters.
See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and
https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.</failure></testcase><testcase classname="tests.test_upload" name="test_upload_malicious_filename" time="0.001"><failure message="Failed: Fixture &quot;mock_user&quot; called directly. Fixtures are not meant to be called directly,&#10;but are created automatically when test functions request them as parameters.&#10;See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and&#10;https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.">Fixture "mock_user" called directly. Fixtures are not meant to be called directly,
but are created automatically when test functions request them as parameters.
See https://docs.pytest.org/en/stable/explanation/fixtures.html for more information about fixtures, and
https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.</failure></testcase></testsuite></testsuites>